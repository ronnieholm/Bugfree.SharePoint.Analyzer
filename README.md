# Bugfree.SharePoint.Analyzer

SharePoint's API isn't optimized for dynamic queries on structural
metadata across web applications, site collections, and webs. In this
context, structural metadata refers to any piece of information
accessible through the SharePoint API which may help answer questions
that help drive migration decisions or ensure governance is adhered
to:

  - Which content types are associated with which document library?
  - Which features are enabled where?
  - When an item in a list was last modified?
  - Which security groups are in effect where?
  - Which pages host which web parts?

While such queries provide valuable inside into how SharePoint is
actually used, in a large farm each may take hours to complete. 

Rather than run multiple queries against the SharePoint API directly,
this project contains of a skeleton exporter/importer pair to project
SharePoint's hierarchical metadata model onto a relational read model
stored in SQL server (via an intermediate XML read model). Using
standard database tools and techniques, most queries can be answered
in a matter of seconds.

Writing the export/import logic ourselves has the benefit of providing
technical feedback about the old platform and help better understand
why the results come out the way they do. For browsing results, plain
SQL result grid or PowerBI are handy.

## How to compile

To compile the exporter, grap a copy of Microsoft.SharePoint.dll from
a SharePoint 2007 server and place it in the libs folder.
Unfortunately, licensing precludes the redistribution of it.

Because of the importer's use of the
[FSharp.Data.SqlClient](http://fsprojects.github.io/FSharp.Data.SqlClient)
type provider, a database with schema matching code is required to
compile the importer. Running the build script creates the database
and compiles both the exporter and importer:

    % .\build.ps1

The LocalDB database generated by the script is solely intended for
use during compilation. To import larger datasets into it, adjust the
database sizes in the script accordingly.

## How to use

Limited by the web services in SharePoint 2007, the exporter must
connect to SharePoint through the server-side object model. This means
running it from a SharePoint server in the farm. A server which is
likely not equipped with the latest in operating systems or .NET
framework. The server may not even have Internet access. 

Thus, the exporter is compiled against .NET Framework 3.5 and .NET
runtime 2.0. To invoke it, provide the web application name as show
below. Surround the argument with quotes if it contains spaces:

    % .\Bugfree.SharePoint.Analyzer.Exporter.exe <web-app-name>
 
The exporter outputs the XML read model as
&lt;web-app-name&gt;.xml. It must be transferred to another computer
running more up-to-date software for import into SQL server. Multiple
XML files may be exported into the same database as long as their web
application names are unique.

With the XML file in hand, the importer is run as below. Surround each
argument with quotes if it contain spaces:

    % .\Bugfree.SharePoint.Analyzer.Importer.exe <web-app-name>.xml <connection-string>

The importer has been tested against both LocalDB and SQL Azure. With
LocalDB, the connection string has the following format:

    Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=<absolute-path-to-mdf>;Integrated Security=True;Connect Timeout=30

## Querying SQL server

To order the list of site collections within a web application by last
list item modification date descending, the following query is
required. It provides a skeleton for how to combine the hierarchical
structure of SharePoint when represented relationally:

```sql
select sc.Url, max(LastModifiedAt) LastModifiedAt from
    (select w.SiteCollectionId, latestsLists.LastModifiedAt from 
        (select l.Title, l.WebId, ListId, LastModifiedAt from
            (select li.ListId, max(li.ModifiedAt) LastModifiedAt
    	     from WebApplications wa
             inner join SiteCollections sc on sc.WebApplicationId = wa.Id
             inner join Webs w on w.SiteCollectionId = sc.Id
             inner join Lists l on l.WebId = w.Id
             inner join ListItems li on li.ListId = l.Id
             where wa.Title = '<webapp-name>'
             group by li.ListId) as latestsItems
             inner join Lists l on l.Id = latestsItems.ListId) as LatestsLists
             inner join Webs w on w.Id = LatestsLists.WebId) as LatestsWebs
    inner join SiteCollections sc on sc.Id = LatestsWebs.SiteCollectionId
    group by sc.Url
    order by LastModifiedAt desc
```

## How it works

The exporter constructs an in-memory XML representation of the
metadata to project. The XML is kept in memory during construction and
may require GBs of memory. The exporter is therefore compiled for 64
bit.

The exporter traverses SharePoint's structure in a depth-first manner,
starting from the web application and moving toward list items. The
importer, on the other hand, contains a recursive descent parser which
does a depth-first traversal of the XML model, emitting SQL insert
statements in the process. 

Every property to retain from SharePoint can be projected onto the XML
model and every part of the XML model can be projected onto the
relational model.

## Notes

The exporter and importer started out with a type-based domain model
of WebApplication, SiteCollection, Web, List, ListItem. Those types
were annotated with DataMember and DataContract attributes to aid the
DataContractSerializer with XML serialization and deserialization. For
some reason, .NET wasn't able to correctly serialize and deserialize
the XML back into objects across .NET versions. Instead, serialization
and deserialization is handcrafted.
    
If the SharePoint 2007 farm would provide an empty database with write
access, we wouldn't need separate exporting and important. But
creating an extra database in a legacy environment isn't always
straightforward. Unfortunately LocalDB isn't supported by .NET 3.5 and
the 2 GB size-limit of SQLite was quickly encountered. Hence the
intermediate XML model.

The libs folder enables compiling the solution on a machine without
SharePoint 2007 installed. Running the exporter on a SharePoint
server, libs content is in the Global Assembly Cache which takes
precedents during fusing.

CPU utilization for the exporter is a few percent only. The database
server is the one doing the heavy lifting.

## Supported platforms

SharePoint 2007 for export, LocalDB or SQL Server, SQL Azure for
import, Visual Studio 2015 for building.